# The YAML is organized like a big tree (mappings within mappings).
#
# I'll call top-level mappings "sections." Some special sections like GROUPS, MODIFIERS, LITERALS
# add specific functionality. (See their usage at the bottom.)
#
# Other (regular) sections are structured such that the leaves (lists and strings) associates key(s)
# to symbol(s), and the "path" to get to that leaf defines the modifiers (and optionally the keycode
# if the leaf does not). Apart from the BASE section, their top-level names is ignored.
#
# Examples are below. These assumes modifiers "shift" (first bit), "alt" (second bit) and "comp"
# (third bit).
#
# Verbose key-by-key assignment:
#
# ------
# IndirectVsDirect:
#   # Indirect assignment to the keycode that was bound to a given symbol in the BASE layer.
#   shift+z: '@' # makes shift+<key_bound_to_z> â‡’ '@'
#   alt+8: 'âˆ' # same deal, alt+<key_that_produces_8> â‡’ âˆ
#
#   # Or use XKB key codes directly:
#   <AB02>: '*' # KEY_X (on QWERTY) becomes '*'
#
# MySectionA:
#   alt:
#     shift:
#       g: '$' # makes shift+alt+g produce symbol $
#
#   # Mods+key can be composed with '+'. Order of mods doesn't matter, but if a key is present it
#   # must be last:
#   alt+shift+y: 'â‰ ' # shift+alt+y â‡’ â‰ 
#
#   # But beware of specifying duplicates:
#   alt: # Error: conflicts with the first `alt` entry.
#     â€¦
#
#   none: # `none` means no mods are added going down this path.
#     shift:
#       p: 'â„™' # shift+p â‡’ â„™
#
#   shift+p: â€¦ # Error: reassigns shift+p.
#
# SectionB:
#   # Sections can have a special `mods` entry which gets implicitly added to all other entries at
#   # this level.
#   mods: shift+comp
#   alt:
#     g: '$' # shift+alt+comp+g => $
# ------
#
# It's usually more convenient to assign many keys at once:
#
# ------
# LevelsByKey:
#   # Using a list will assign many levels at once.
#   alt+h: ['âˆˆ', 'âˆ‰', '%', 'Ã·']
#
#   # Note that modifiers are like bits, so <alt> + 2 â†’ <comp>, so the above is equivalent to:
#   h:
#     alt: 'âˆˆ'
#     shift+alt: 'âˆ‰'
#     comp: '%'
#     shift+comp: 'Ã·'
#
# RowByRow:
#   # Any number comp+<keys> specified in a row-by-row way:
#   comp:
#     - [ '/', '1', '2', â€¦] # The ellipses just indicate elision, it is not part of the syntax
#     - [ q, w, f, â€¦]
#     - [ a, r, s, â€¦]
#     - [ z, x, â€¦]
#
# AlphabetStrings:
#   # if the leaf is a string of length 26 it's interpreted as specifying <mods>+a, <mods>+b, etc.
#   alt: "ğ”ğ”Ÿğ” ğ”¡ğ”¢ğ”£ğ”¤ğ”¥ğ”¦ğ”§ğ”¨ğ”©ğ”ªğ”«ğ”¬ğ”­ğ”®ğ”¯ğ”°ğ”±ğ”²ğ”³ğ”´ğ”µğ”¶ğ”·'
#
#   # if the leaf is a string of length 10 it's interpreted as specifying <mods>+0, <mods>+1, etc.
#   alt: "â‚€â‚â‚‚â‚ƒâ‚„â‚…â‚†â‚‡â‚ˆâ‚‰"
# ------
#
# Most places where you specify a single symbol with 'x', you also use a string with _two_ symbols
# to assign both <mods>+<key> and shift+<mods>+<key> at the same time:
#
# ------
# NormalAndShift:
#   alt+w: "â‰ˆâ‰‰" # alt+w â‡’ â‰ˆ, shift+alt+w â‡’ â‰‰
# ------
#
# Finally, sections may have a special `group` entry that causes all its leaves to be put into a
# different group. Currently I only use latched groups. After you've pressed the latch key the next
# key-combination you enter is looked up in that group instead of the default one, and then the
# latch resets. You can think of latch keys as a dead-key, the way you would on some systems press
# <umlaut (Â¨)> and then <a> to produce 'Ã¤'.
#
# GROUPS:
#   emo: '<AE11>' # defines the latch key.
#
# ExtraStuff:
#   group: emo
#   a: "â˜¹" # <AE11> â‡’ a â‡’ â˜¹
#   alt-a: "â˜¯" # <AE11> â‡’ alt+a â‡’ â˜¯


# The base of the keymap. This will be processed first and should at the very least map symbols
# in the first group1 layer.
BASE:
  none:
    - [ '/',  '1',  '2',  '3',  '4',  '5',  '6',  '7',  '8',  '9',  '0',  null,  null ]
    - [ 'q',  'w',  'f',  'p',  'g',  'j',  'l',  'u',  'y',  'Ã¸',  'Ã¥',  'Ã¦' ]
    - [ 'a',  'r',  's',  't',  'd',  'h',  'n',  'e',  'i',  'o',  "'",  '`' ]
    - [ '/',  'z',  'x',  'c',  'v',  'b',  'k',  'm',  ',',  '.',  '-' ]
  shift:
    - [ '|',  '',   '',   '',   '',   '',   '',   '',   '',   '',   '',   '',   '' ]
    - [ 'Q',  'W',  'F',  'P',  'G',  'J',  'L',  'U',  'Y',  'Ã˜',  'Ã…',  'Ã†' ]
    - [ 'A',  'R',  'S',  'T',  'D',  'H',  'N',  'E',  'I',  'O',  '"',  '|' ]
    - [ '|',  'Z',  'X',  'C',  'V',  'B',  'K',  'M',  ';',  ':',  'â€”' ]

Sub- and Superscript Numbers:
  shift: "â°Â¹Â²Â³â´âµâ¶â·â¸â¹"
  alt: "â‚€â‚â‚‚â‚ƒâ‚„â‚…â‚†â‚‡â‚ˆâ‚‰"

Symbols and Accents:
  mods: alt
  none:
    - [ '\â€–' ] # The rest is subscript.
    - [ '?Â¿',  '!Â¡',  '$â‚¬',  '+Â±',  '&',  '',   '%Ã·',  '_',  '=â‰ ',  'Â¨',  'Â°',  'Ë‡' ]
    - [ '@',  '{',  '[âŸ¦',  '(',  '<â‰¤',  '>â‰¥',  ')',  ']âŸ§',  '}',  '~',  '',  '' ]
    - [ '\â€–', 'âˆˆâˆ‰',  'Ã—â¨¯',  '^',  'Â¬',   '#â™¯',  'â‰…â‰‡',  '*',  '',  'â‹…',  'â€¦' ]
  # None of these should conflict with the above.
  shift:
    '2': 'combining double acute accent'
    '8': 'combining infinity'
    'u': 'combining low line'
    'Ã¥': 'combining ring above'
    'Ã¸': 'combining diaeresis'
    'Ã¦': 'combining caron'
    'i': 'combining dot above'
    'o': 'combining tilde'
    "'": 'combining acute accent'
    "`": 'combining grave accent'
    'c': 'combining circumflex accent'
    'm': 'combining macron'
    ',': 'combining cedilla'
    '.': 'combining dot below'
    '-': 'combining long stroke overlay'

Comp Layer:
  comp:
    - [ 'Â¦', 'Â§Â¶',   '',   'Â¢Â£',   'Â¤Â¥',   '',   '',   '',   '',   '',   '',   '',   '' ]
    - [ '',  '',  '',  '',  '',  '',  'â†•â‡•',  'â†‘â‡‘',  'â†”â‡”',  '',  '',  '' ]
    - [ '',  '',  '',  '',  '',  '',  'â†â‡',  'â†“â‡“',  'â†’â‡’',  '',  "",  '' ]
    - [ 'Â¦',  '',  'âœ•',  '',  '',  '',  '',  'Âµ',  '',  '',  '' ]

Extra Su*script:
  mods: comp+alt
  none: "â‚...â‚‘..â‚•áµ¢â±¼â‚–â‚—â‚˜â‚™â‚’â‚š.áµ£â‚›â‚œáµ¤áµ¥.â‚“.."
  shift: "áµƒáµ‡á¶œáµˆáµ‰á¶ áµÊ°â±Ê²áµË¡áµâ¿áµ’áµ–ğ¥Ê³Ë¢áµ—áµ˜áµ›Ê·Ë£Ê¸á¶»"
  '.': 'â‚”áµŠ'
  '-': 'â‚‹â»'
  "'": 'â‚â½'
  '`': 'â‚â¾'
  <AE11>: 'â‚Šâº'
  <AE12>: 'â‚Œâ¼'


Extra Alphabets:
  group: alphabets

  # Math letters.
  none:           'ğ‘ğ‘ğ‘ğ‘‘ğ‘’ğ‘“ğ‘”â„ğ‘–ğ‘—ğ‘˜ğ‘™ğ‘šğ‘›ğ‘œğ‘ğ‘ğ‘Ÿğ‘ ğ‘¡ğ‘¢ğ‘£ğ‘¤ğ‘¥ğ‘¦ğ‘§'
  shift:          'ğ”¸ğ”¹â„‚ğ”»ğ”¼ğ”½ğ”¾â„ğ•€ğ•ğ•‚ğ•ƒğ•„â„•ğ•†â„™â„šâ„ğ•Šğ•‹ğ•Œğ•ğ•ğ•ğ•â„¤'
  alt:            'Î±Î²Ï‡Î´ÎµÏ†Î³Î¸Î¹?ÎºÎ»Î¼Î·Ï‰Ï€?ÏÏƒÏ„Ï…Î½ÏˆÎ¾Ï…Î¶'
  alt+shift:      '???Î”ÏµÎ¦Î“Î˜???Î›??Î©???Î£???Î¨Î??'
  comp+alt:       'ğ”ğ”Ÿğ” ğ”¡ğ”¢ğ”£ğ”¤ğ”¥ğ”¦ğ”§ğ”¨ğ”©ğ”ªğ”«ğ”¬ğ”­ğ”®ğ”¯ğ”°ğ”±ğ”²ğ”³ğ”´ğ”µğ”¶ğ”·'
  comp+alt+shift: 'ğšğ›ğœğğğŸğ ğ¡ğ¢ğ£ğ¤ğ¥ğ¦ğ§ğ¨ğ©ğªğ«ğ¬ğ­ğ®ğ¯ğ°ğ±ğ²ğ³'
  # Various other weird/int'l letters.
  comp:
    l: ['Å‚', 'Å']
    Ã¸: ['Å“', 'Å’']
    a: ['â„µ']
    s: ['ÃŸ', 'áº']
    t: ['Ã¾', 'Ã']
    d: ['Ã°', 'Ã']
    h: ['Ä§', 'Ä¦']
    n: ['Å‹', 'ÅŠ']
    e: ['É™', 'Æ']
    z: ['Å¿']

# Math and more symbols.
Math:
  group: math

  none:
    - [ '',   '',   'âˆšâ·', 'âˆ›',  'âˆœ',  'âˆ®âˆ¬',   '',   '',   'âˆ',  '9', 'â€‹â€', '',   '' ]
    - [ 'âˆ',  'âˆ´âˆµ',  '', 'âŠ•âŠ',   '',  '',  'â„“â„’',  'u',  'â‰¡â‰¢', 'âˆ…', 'âŒŠâŒˆ', 'âŒ‹âŒ‰' ]
    - [ 'âˆ€',  'â„›',  'âˆ‘âˆ', 'âŠ¤âŠ¥',  'â‹„',  'â„‹',  'n',  'âˆƒâˆ„', 'âˆ†âˆ‡',  'âˆ˜âˆ™', 'â€¹Â«',  'â€ºÂ»' ]
    - [ 'âˆ•âˆ£', 'âˆŠ', 'âŠ—âŠ ', 'âˆ‚âˆ«',  'âˆ¨âˆ§',  '',  'â‰ƒâ‰„', 'â‹†âˆ—', 'â‹®',  'âŠ™âŠ¡', 'âŠ–âŠŸ' ]

  alt:
    - [ '',   '',   '',   '',   '',   '',   '',   '',   '', '',   '',  null, null ]
    - [ 'â‰Ÿâ‰œ',   '',  'â„¯â„°',  'âˆ',  'â„Š',  '',   'â„’',  'âˆªâˆ©', 'â‰ˆâ‰‰', 'â„˜',   '',  '' ]
    - [ 'âˆ âˆ¡', 'âŠ²âŠ´', 'ã€–ã€', 'âŠ†âŠˆ', 'âŠ‚âŠ„', 'âŠƒâŠ…', 'âŠ‡âŠ‰', 'ã€—ã€‘', 'âŠ³âŠµ', '', 'â‰ªâ‹˜', 'â‰«â‹™' ]
    - [ '',    'âˆˆâˆ‰',   '',   '',   '',   '',   '',   'â‰›',   '', '', '' ]

  comp:
    - [ '',   '',   '',   '',   '',   '',   '',   '',   '', '',   '',  null, null ]
    - [ '',   '',    '',  '',    '',  '',   '',    '',   '',   '',   '',  '' ]
    - [ '',   'âŠ‘â‹¤', 'âŠâ‹¢', 'â‰¼â‹ ', 'â‰ºâŠ€', 'â‰»âŠ', 'â‰½â‹¡', 'âŠâ‹£', 'âŠ’â‹¥', '', '', '' ]
    - [ '',    '',   '',   '',   '',   '',   '',   '',   '', '', ' ' ]


# âŸ¬âŸ­

# Extra extra scripts:
Extra-Scripts:
  group: other
  none:
    - [ '', 'Â½', 'â…“â…”', 'Â¼Â¾', 'â…•â…˜', 'â…™â…š', 'â…', 'â…›â…', 'â…‘' ]
  alt:
    - [ '', '', '', '', 'â…–â…—', '', '', 'â…œâ…', '' ]

  comp:
    - [ '',   'â˜¹',  'â˜ºâ˜»', '',   '',   '',   '',   '',  'à¿•à¿—', 'à¿–à¿˜', '',  '', '' ]
    - [ 'â™•â™›', 'â‰â€¼', 'â™€â™‚', '',   '',   '',   '',   '',  'â˜¯',  '',   '',  ' ' ]
    - [ 'âš•',  'Â®',  'â˜†â˜…', 'âœâœš', '',   'â™¡â¤', '',   '',  'âšš',  '',   'â—€', 'â–¶' ]
    - [ '',   '',   'âœ—âœ˜', 'Â©',  'âœ“âœ”', '',   'â™”â™š', 'â„¢', '',   '',   '' ]


Extra-Scripts Alphabets:
  group: other

  none: "ğ’¶ğ’·ğ’¸ğ’¹â„¯ğ’»â„Šğ’½ğ’¾ğ’¿ğ“€ğ“ğ“‚ğ“ƒâ„´ğ“…ğ“†ğ“‡ğ“ˆğ“‰ğ“Šğ“‹ğ“Œğ“ğ“ğ“"
  shift: "ğ’œâ„¬ğ’ğ’Ÿâ„°â„±ğ’¢â„‹â„ğ’¥ğ’¦â„’â„³ğ’©ğ’ªğ’«ğ’¬â„›ğ’®ğ’¯ğ’°ğ’±ğ’²ğ’³ğ’´ğ’µ"
  alt: "ğ“ªğ“«ğ“¬ğ“­ğ“®ğ“¯ğ“°ğ“±ğ“²ğ“³ğ“´ğ“µğ“¶ğ“·ğ“¸ğ“¹ğ“ºğ“»ğ“¼ğ“½ğ“¾ğ“¿ğ”€ğ”ğ”‚ğ”ƒ"
  alt+shift: "ğ“ğ“‘ğ“’ğ““ğ“”ğ“•ğ“–ğ“—ğ“˜ğ“™ğ“šğ“›ğ“œğ“ğ“ğ“Ÿğ“ ğ“¡ğ“¢ğ“£ğ“¤ğ“¥ğ“¦ğ“§ğ“¨ğ“©"


# Defines the modifiers. These are used to traverse the other sections. Note: per now, only the
# entries mapped to mod Shift, LevelThree, or LevelFive are used for the other sections.
MODIFIERS:
  shift:
    keycodes: [ '<LFSH>', '<RTSH>' ]
    keysyms: [ Shift_L, Shift_R ]
    mod: Shift

  alt:
    keycodes: [ '<RALT>' ]
    keysyms: ISO_Level3_Shift
    mod: LevelThree
    x11: None # Hides it in X11.

  comp:
    # In my experience, manufacturers love to randomize the keys they include on the right side of
    # Spacebar. These are the keys I've encountered beyond <RALT>. Normally there will be <RALT>,
    # <RCTRL>, with 0-2 RANDOM keys between them. Often they stick those retarded hardware-only "Fn"
    # keys in there too. Note: <COMP> and <MENU> is the same keycode(?) so no need to bind both.
    keycodes: [ '<COMP>', '<RCTL>', '<RWIN>', '<PRSC>' ] 
    keysyms: ISO_Level5_Shift
    mod: LevelFive
    x11: None

  # For i3, my window manager.
  super:
    keycodes: [ '<LWIN>' ]
    keysyms: Super_L
    mod: Super
    x11: Mod4 # Adds a `modifier_map <key> { <mod> };` entry.

  # On one of my laptops <I151> is a non-hardware Fn key conveniently placed where <RCTL> _ought_ to
  # be.
  ctrl:
    keycodes: [ '<LCTL>', '<I151>' ]
    keysyms: Control_L
    x11: Control

# Defines the latch groups and the key used to access them. These keys must be specified by XKB
# code. Note: XKB/X11 has a hard limit of 4 groups (protocol uses 2 bits). That's why we push so
# much into layers instead.
GROUPS:
  math: '<AE11>' # key right of '0'
  alphabets: '<AE12>' # key left of Backspace.
  other: 'shift+<AE11>'


# Special section to copy stuff literally to the XKB output (in `xkb_symbols`).
LITERALS:
  # Assign the arrow keys and all that noise.
  basic_map: |
    include "pc+no(colemak)" // my basic layout is a Colemak-based Norwegian-ish layout.
  # Surely no intelligent person thinks they make so few mistakes typing that it makes sense to
  # place Backspace in Siberia.
  sane_backspace: |
    include "capslock(backspace)"

# Whenever we specify symbols by rows, this defines the keycodes to map them to. The one specified
# here matches most Scandinavian keyboard.
ROWS:
  - ['<TLDE>', '<AE01>', '<AE02>', '<AE03>', '<AE04>', '<AE05>', '<AE06>', '<AE07>', '<AE08>', '<AE09>', '<AE10>', '<AE11>', '<AE12>']
  - ['<AD01>', '<AD02>', '<AD03>', '<AD04>', '<AD05>', '<AD06>', '<AD07>', '<AD08>', '<AD09>', '<AD10>', '<AD11>', '<AD12>']
  - ['<AC01>', '<AC02>', '<AC03>', '<AC04>', '<AC05>', '<AC06>', '<AC07>', '<AC08>', '<AC09>', '<AC10>', '<AC11>', '<BKSL>']
  - ['<LSGT>', '<AB01>', '<AB02>', '<AB03>', '<AB04>', '<AB05>', '<AB06>', '<AB07>', '<AB08>', '<AB09>', '<AB10>' ]
  - ['<SPCE>']


# TODO:
# ğ’œğ’ğ’Ÿğ’¢ğ’¥ğ’¦ğ’©ğ’ªğ’«ğ’¬ğ’®ğ’¯ğ’°ğ’±ğ’²ğ’³ğ’´ğ’µ
# ğ’¶ğ’·ğ’¸ğ’¹-ğ’»-ğ’½ğ’¾ğ’¿ğ“€ğ“ğ“‚ğ“ƒ-ğ“…ğ“†ğ“‡ğ“ˆğ“‰ğ“Šğ“‹ğ“Œğ“ğ“ğ“



